package state

import "fmt"

type Output struct {
	Value interface{} `json:"value"`
}

type Resource struct {
	Mode      string        `json:"mode"`
	Type      string        `json:"type"`
	Name      string        `json:"name"`
	Provider  string        `json:"provider"`
	Module    string        `json:"module"`
	Instances []interface{} `json:"instances"`
}

func (t *Resource) Key() string {
	if t.Mode != "managed" {
		return fmt.Sprintf("%s.%s.%s", t.Mode, t.Type, t.Name)
	}
	return fmt.Sprintf("%s.%s", t.Type, t.Name)
}

// State is a top level entity in a Terraform state file.
type State struct {
	// Version of the state schema being used
	Version int `json:"version"`
	// TerraformVersion used in the creation of the state file
	TerraformVersion string `json:"terraform_version"`
	// Serial is the version of the state file (increments per apply, destroy)
	Serial int64 `json:"serial"`
	// A UUID generated by terraform when is changed, used for hashing
	Lineage string `json:"lineage"`
	// Outpus contains Terraform outputs
	Outputs map[string]Output `json:"outputs,omitempty"`
	// Resources contains all terraform resources including data types.
	Resources []Resource `json:"resources,omitempty"`
}

// FilterByMode allows use to filter by a specific mode, E.G data, managed
func (t *State) FilterByMode(mode string) []Resource {
	var resources []Resource
	for _, r := range t.Resources {
		if r.Mode == mode {
			resources = append(resources, r)
		}
	}
	return resources
}

// ManagedResources filters out resources that are managed by Terraform
func (t *State) ManagedResources() []Resource {
	return t.FilterByMode("managed")
}
